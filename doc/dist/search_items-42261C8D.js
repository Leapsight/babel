searchNodes=[{"doc":"This module acts as entry point for a number of Babel features and provides some of the riakc_pb_socket module functions adapted for babel datatypes. ### Working with Babel Datatypes ### Working with Reliable Workflows #### Workflow aware functions A workflow aware function is a function that schedules its execution when it is called inside a workflow context. Several functions in this module are workflow aware e.g. put/5 , delete/3 . ### Working with Babel Indices","ref":"babel.html","title":"babel","type":"module"},{"doc":"Calls create_index/3 passing the default options as third argument.","ref":"babel.html#create_index/2","title":"babel.create_index/2","type":"function"},{"doc":"Schedules the creation of an index and its partitions according to Config using Reliable. The updated collection is returned under the key result of the reliable:wf_result() . ?&gt; This function uses a workflow, see workflow/2 for an explanation of the possible return values.","ref":"babel.html#create_index/3","title":"babel.create_index/3","type":"function"},{"doc":"?&gt; This function is workflow aware","ref":"babel.html#delete/3","title":"babel.delete/3","type":"function"},{"doc":"Calls drop_all_indices/3","ref":"babel.html#drop_all_indices/1","title":"babel.drop_all_indices/1","type":"function"},{"doc":"Drops all indices in collection by calling drop_indices/3 .","ref":"babel.html#drop_all_indices/2","title":"babel.drop_all_indices/2","type":"function"},{"doc":"","ref":"babel.html#drop_index/2","title":"babel.drop_index/2","type":"function"},{"doc":"Schedules the removal of the index with name IndexName from collection Collection and all its index partitions from Riak KV. In case the collection is itself being dropped by a parent workflow, the collection will not be updated in Riak. ?&gt; This function uses a workflow, see workflow/2 for an explanation of the possible return values.","ref":"babel.html#drop_index/3","title":"babel.drop_index/3","type":"function"},{"doc":"Calls drop_indices/3","ref":"babel.html#drop_indices/2","title":"babel.drop_indices/2","type":"function"},{"doc":"Schedules the removal from Riak KV of indices with names IdxNames from collection Collection and their respective partitions. ?&gt; This function uses a workflow, see workflow/2 for an explanation of the possible return values.","ref":"babel.html#drop_indices/3","title":"babel.drop_indices/3","type":"function"},{"doc":"Executes a number of operations using the same Riak client connection provided by riak_pool app. Poolname must be an already started pool or the atom undefined . In case of the latter the map Options should have an entry for the connection key. Options: * timeout - time to get a connection from the pool * connection - the pid to use instead of getting a new one from the pool","ref":"babel.html#execute/3","title":"babel.execute/3","type":"function"},{"doc":"Retrieves a Riak Datatype (counter, set or map) from bucket type and bucket TypedBucket and key Key . It uses type spec Spec to transform the Riak Datatype into a Babel Datatype and if successful returns {ok, Datatype} where Datatype is one of babel_counter , babel_set or babel_map . Returns {error, not_found} if the key is not on the server. This function gets the riak client connection from the options Opts under the key connection which can have the connection pid or a function object returning a connection pid. This allows a lot of flexibility such as reusing a given connection over several calls and using your own connection pool and management. In case the connection option does not provide a connection as explained above, this function tries to get a connection from the the default riak_pool connection pool if it was enabled through Babel's configuration options.","ref":"babel.html#get/4","title":"babel.get/4","type":"function"},{"doc":"Returns a Riak connection managed by riak_pool from the process dictonary or undefined if there is none.","ref":"babel.html#get_connection/0","title":"babel.get_connection/0","type":"function"},{"doc":"Returns the module associated with the type of term Term .","ref":"babel.html#module/1","title":"babel.module/1","type":"function"},{"doc":"Converts the options map into Riak KV property list format. It fails with a badarg exception if Opts is not the result of validate_opts/3 .","ref":"babel.html#opts_to_riak_opts/1","title":"babel.opts_to_riak_opts/1","type":"function"},{"doc":"Transforms the datatype Datatype to a Riak Datatype using type specification Spec and stores it under TypedBucket and Key using options Opts. When called outside a workflow it returns `ok or {error, Reason} . ?&gt; This function is workflow aware. See workflow/2 to understand the result value.","ref":"babel.html#put/5","title":"babel.put/5","type":"function"},{"doc":"","ref":"babel.html#rebuild_index/3","title":"babel.rebuild_index/3","type":"function"},{"doc":"Calls status/2 .","ref":"babel.html#status/1","title":"babel.status/1","type":"function"},{"doc":"Returns the status of a Reliable Work scheduled for execution. !&gt; **Important** notice that at the moment completed tasks are deleted, so the abscense of a task is considered as either successful or failed, this will change in the near future as we will be retaining tasks that are discarded or completed.","ref":"babel.html#status/2","title":"babel.status/2","type":"function"},{"doc":"Returns the atom name for a babel datatype.","ref":"babel.html#type/1","title":"babel.type/1","type":"function"},{"doc":"Updates all the indices in the collection that are affected by he provided Actions and schedules the update of the relevant index partitions in the database i.e. persisting the index changes. An index in collection Collection will always be affectd in case the action is either {insert, Data} or {delete, Data} or when the action is {udpate, Old, New} and the option force was set to true or when New is not a babel map. In case option object New is a babel map, and the option force is missing or set to false , an index will be affected by an update action only if the index's distinguished key paths have been updated or removed in the object New (See babel_index:distinguished_key_paths/1 ) ?&gt; This function uses a workflow, see workflow/2 for an explanation of the possible return values.","ref":"babel.html#update_all_indices/3","title":"babel.update_all_indices/3","type":"function"},{"doc":"Updates all the indices in the collection with the provided Actions and schedules the update of the relevant index partitions in the database i.e. persisting the index changes. The names of the updated indices is returned under the key result of the reliable:wf_result() . ?&gt; This function uses a workflow, see workflow/2 for an explanation of the possible return values.","ref":"babel.html#update_indices/3","title":"babel.update_indices/3","type":"function"},{"doc":"Updates all the indices in the collection with the provided Actions and schedules the update of the relevant index partitions in the database i.e. persisting the index changes. The names of the updated indices is returned under the key result of the reliable:wf_result() . ?&gt; This function uses a workflow, see workflow/2 for an explanation of the possible return values.","ref":"babel.html#update_indices/4","title":"babel.update_indices/4","type":"function"},{"doc":"Equivalent to validate_opts(Op, Opts, strict) . Validates the options Opts for an operation Op . See also: validate_opts/3 .","ref":"babel.html#validate_opts/2","title":"babel.validate_opts/2","type":"function"},{"doc":"Validates the options","ref":"babel.html#validate_opts/3","title":"babel.validate_opts/3","type":"function"},{"doc":"Equivalent to calling workflow/2 with and empty map passed as the Opts argument. &gt; Notice subscriptions are not working at the moment &gt; See yield/2 to track progress.","ref":"babel.html#workflow/1","title":"babel.workflow/1","type":"function"},{"doc":"Executes the functional object Fun as a Reliable workflow, i.e. ordering and scheduling all resulting Riak KV object writes. The code that executes inside the workflow should call one or more functions in this module to schedule writes in Riak KV. For example, if you wanted to schedule an index creation you should use create_index/2 instead of babel_index_collection , babel_index and babel_index_partition functions directly. Any other operation, including reading and writing from/to Riak KV directly or by using the API provided by other Babel modules will work as normal and will not affect the workflow, only the special functions in this module will add work items to the workflow. If something goes wrong inside the workflow as a result of a user error or general exception, the entire workflow is terminated and the function raises an exception. In case of an internal error, the function returns the tuple {error, Reason} . If everything goes well, the function returns the tuple {Flag, Result}} where Flag is a boolean denoting whether a workflow was scheduled or not, and Result is a reliable:wf_result() structure. &gt; Notice that calling this function schedules the work to Reliable, you need to use the WorkId to check with Reliable the status of the workflow execution. Example: Creating various babel objects and scheduling babel:workflow(fun() -&gt; CollectionX0 = babel_index_collection:new(&lt;&lt;&quot;foo&quot;&gt;&gt;, &lt;&lt;&quot;bar&quot;&gt;&gt;), CollectionY0 = babel_index_collection:fetch(Conn, &lt;&lt;&quot;foo&quot;&gt;&gt;, &lt;&lt;&quot;users&quot;&gt;&gt;), IndexA = babel_index:new(ConfigA), IndexB = babel_index:new(ConfigB), _CollectionX1 = babel:create_index(IndexA, CollectionX0), _CollectionY1 = babel:create_index(IndexB, CollectionY0), ok end). The resulting workflow execution will schedule the writes and deletes in the order defined by the dependency graph constructed using the results of this module functions. This ensures partitions are created first and then collections. The Opts argument offers the following options: * on_terminate` – a functional object `fun((Reason :: any()) -&gt; ok) . This function will be evaluated before the call terminates. In case of succesful termination the value normal will be passed as argument. Otherwise, in case of error, the error reason will be passed as argument. This allows you to perform a cleanup after the workflow execution e.g. returning a riak connection object to a pool. Notice that this function might be called multiple times in the case of nested workflows. If you need to conditionally perform a cleanup operation you might use the function is_nested_worflow/0 to take a decision. !&gt; **Important** notice subscriptions are not working at the moment ?&gt; **Tip** See yield/2 to track progress. ?&gt; **Note on Nested workflows**. No final scheduling will be done until the top level workflow is terminated. So, although a nested worflow returns {true, Result} , if the enclosing parent workflow is aborted, the entire nested workflow is aborted.","ref":"babel.html#workflow/2","title":"babel.workflow/2","type":"function"},{"doc":"Returns the value associated with the key event_payload when used as option from a previous enqueue/2 . The calling process is suspended until the work is completed or !&gt; **Important** notice the current implementation is not ideal as it recursively reads the status from the database. So do not abuse it. Also at the moment completed tasks are deleted, so the abscense of a task is considered as either successful or failed, this will also change as we will be retaining tasks that are discarded or completed. This will be replaced by a pubsub version soon.","ref":"babel.html#yield/1","title":"babel.yield/1","type":"function"},{"doc":"Returns the value associated with the key event_payload when used as option from a previous enqueue/2 or timeout when Timeout milliseconds has elapsed. !&gt; **Important** notice The current implementation is not ideal as it recursively reads the status from the database. So do not abuse it. Also at the moment complete tasks are deleted, so the abscense of a task is considered as either succesful or failed, this will also change as we will be retaining tasks that are discarded or completed. This will be replaced by a pubsub version soon.","ref":"babel.html#yield/2","title":"babel.yield/2","type":"function"},{"doc":"","ref":"babel.html#t:bucket/0","title":"babel.bucket/0","type":"type"},{"doc":"","ref":"babel.html#t:bucket_and_type/0","title":"babel.bucket_and_type/0","type":"type"},{"doc":"","ref":"babel.html#t:bucket_type/0","title":"babel.bucket_type/0","type":"type"},{"doc":"","ref":"babel.html#t:datatype/0","title":"babel.datatype/0","type":"type"},{"doc":"","ref":"babel.html#t:delete_opts/0","title":"babel.delete_opts/0","type":"type"},{"doc":"","ref":"babel.html#t:get_opts/0","title":"babel.get_opts/0","type":"type"},{"doc":"","ref":"babel.html#t:opts/0","title":"babel.opts/0","type":"type"},{"doc":"","ref":"babel.html#t:put_opts/0","title":"babel.put_opts/0","type":"type"},{"doc":"","ref":"babel.html#t:quorum/0","title":"babel.quorum/0","type":"type"},{"doc":"","ref":"babel.html#t:riak_op/0","title":"babel.riak_op/0","type":"type"},{"doc":"","ref":"babel.html#t:type_spec/0","title":"babel.type_spec/0","type":"type"},{"doc":"","ref":"babel_app.html","title":"babel_app","type":"module"},{"doc":"","ref":"babel_app.html#start/2","title":"babel_app.start/2","type":"function"},{"doc":"","ref":"babel_app.html#stop/1","title":"babel_app.stop/1","type":"function"},{"doc":"","ref":"babel_config.html","title":"babel_config","type":"module"},{"doc":"","ref":"babel_config.html#get/1","title":"babel_config.get/1","type":"function"},{"doc":"","ref":"babel_config.html#get/2","title":"babel_config.get/2","type":"function"},{"doc":"","ref":"babel_config.html#init/0","title":"babel_config.init/0","type":"function"},{"doc":"","ref":"babel_config.html#set/2","title":"babel_config.set/2","type":"function"},{"doc":"It uses Jump Consistent Hash algorithm described in [A Fast, Minimal Memory, Consistent Hash Algorithm](https://arxiv.org/ftp/ arxiv/papers/1406/1406.2294.pdf).","ref":"babel_consistent_hashing.html","title":"babel_consistent_hashing","type":"module"},{"doc":"","ref":"babel_consistent_hashing.html#bucket/2","title":"babel_consistent_hashing.bucket/2","type":"function"},{"doc":"","ref":"babel_consistent_hashing.html#bucket/3","title":"babel_consistent_hashing.bucket/3","type":"function"},{"doc":"Counters are a bucket-level data type that can be used by themselves, associated with a bucket/key pair, or used within a babel_map . A counter’s value can only be a positive integer, negative integer, or zero.","ref":"babel_counter.html","title":"babel_counter","type":"module"},{"doc":"Returns the Riak KV context","ref":"babel_counter.html#context/1","title":"babel_counter.context/1","type":"function"},{"doc":"Decrements the counter by 1.","ref":"babel_counter.html#decrement/1","title":"babel_counter.decrement/1","type":"function"},{"doc":"Decrements the counter by amount Amount .","ref":"babel_counter.html#decrement/2","title":"babel_counter.decrement/2","type":"function"},{"doc":"","ref":"babel_counter.html#from_riak_counter/2","title":"babel_counter.from_riak_counter/2","type":"function"},{"doc":"Increments the counter by 1.","ref":"babel_counter.html#increment/1","title":"babel_counter.increment/1","type":"function"},{"doc":"Increments the counter by amount Amount .","ref":"babel_counter.html#increment/2","title":"babel_counter.increment/2","type":"function"},{"doc":"","ref":"babel_counter.html#is_type/1","title":"babel_counter.is_type/1","type":"function"},{"doc":"","ref":"babel_counter.html#is_valid_type_spec/1","title":"babel_counter.is_valid_type_spec/1","type":"function"},{"doc":"","ref":"babel_counter.html#new/0","title":"babel_counter.new/0","type":"function"},{"doc":"","ref":"babel_counter.html#new/1","title":"babel_counter.new/1","type":"function"},{"doc":"Returns the original value of the counter.","ref":"babel_counter.html#original_value/1","title":"babel_counter.original_value/1","type":"function"},{"doc":"Increments or decrements the counter so that the result of calling value/1 would be equal to amount Amount .","ref":"babel_counter.html#set/2","title":"babel_counter.set/2","type":"function"},{"doc":"This has call has no effect and it is provided for compliance withe the datatype interface.","ref":"babel_counter.html#set_context/2","title":"babel_counter.set_context/2","type":"function"},{"doc":"","ref":"babel_counter.html#to_riak_op/2","title":"babel_counter.to_riak_op/2","type":"function"},{"doc":"Returns the symbolic name of this container.","ref":"babel_counter.html#type/0","title":"babel_counter.type/0","type":"function"},{"doc":"Returns the current value of the counter.","ref":"babel_counter.html#value/1","title":"babel_counter.value/1","type":"function"},{"doc":"","ref":"babel_counter.html#t:babel_context/0","title":"babel_counter.babel_context/0","type":"type"},{"doc":"","ref":"babel_counter.html#t:maybe_no_return/1","title":"babel_counter.maybe_no_return/1","type":"type"},{"doc":"","ref":"babel_counter.html#t:t/0","title":"babel_counter.t/0","type":"opaque"},{"doc":"","ref":"babel_counter.html#t:type_spec/0","title":"babel_counter.type_spec/0","type":"type"},{"doc":"","ref":"babel_crdt.html","title":"babel_crdt","type":"module"},{"doc":"Returns the &quot;unwrapped&quot; value associated with the key in the map. As opposed to riakc_map:fetch/2 this function searches for the key in the removed and updated private structures of the map first. If the key was found on the removed set, fails with a removed exception. If they key was in the updated set, it returns the updated value otherwise calls riakc_map:fetch/2.","ref":"babel_crdt.html#dirty_fetch/2","title":"babel_crdt.dirty_fetch/2","type":"function"},{"doc":"","ref":"babel_crdt.html#dirty_fetch_keys/1","title":"babel_crdt.dirty_fetch_keys/1","type":"function"},{"doc":"","ref":"babel_crdt.html#map_entry/3","title":"babel_crdt.map_entry/3","type":"function"},{"doc":"","ref":"babel_crdt.html#register_to_atom/2","title":"babel_crdt.register_to_atom/2","type":"function"},{"doc":"","ref":"babel_crdt.html#register_to_binary/1","title":"babel_crdt.register_to_binary/1","type":"function"},{"doc":"","ref":"babel_crdt.html#register_to_existing_atom/2","title":"babel_crdt.register_to_existing_atom/2","type":"function"},{"doc":"","ref":"babel_crdt.html#register_to_integer/1","title":"babel_crdt.register_to_integer/1","type":"function"},{"doc":"","ref":"babel_crdt.html#register_to_integer/2","title":"babel_crdt.register_to_integer/2","type":"function"},{"doc":"","ref":"babel_crdt.html#register_to_term/1","title":"babel_crdt.register_to_term/1","type":"function"},{"doc":"","ref":"babel_crdt.html#to_integer/1","title":"babel_crdt.to_integer/1","type":"function"},{"doc":"","ref":"babel_crdt.html#type/1","title":"babel_crdt.type/1","type":"function"},{"doc":"","ref":"babel_crdt.html#t:maybe_no_return/1","title":"babel_crdt.maybe_no_return/1","type":"type"},{"doc":"Flags behave much like Boolean values, except that instead of true or false flags have the values enable or disable. Flags cannot be used on their own, i.e. a flag cannot be stored in a bucket/ key by itself. Instead, flags can only be stored within maps. To disable an existing flag, you have to read it or provide a context.","ref":"babel_flag.html","title":"babel_flag","type":"module"},{"doc":"Returns the Riak KV context","ref":"babel_flag.html#context/1","title":"babel_flag.context/1","type":"function"},{"doc":"Disables the flag, setting its value to false.","ref":"babel_flag.html#disable/1","title":"babel_flag.disable/1","type":"function"},{"doc":"Enables the flag, setting its value to true.","ref":"babel_flag.html#enable/1","title":"babel_flag.enable/1","type":"function"},{"doc":"","ref":"babel_flag.html#from_riak_flag/3","title":"babel_flag.from_riak_flag/3","type":"function"},{"doc":"","ref":"babel_flag.html#is_type/1","title":"babel_flag.is_type/1","type":"function"},{"doc":"","ref":"babel_flag.html#is_valid_type_spec/1","title":"babel_flag.is_valid_type_spec/1","type":"function"},{"doc":"","ref":"babel_flag.html#new/0","title":"babel_flag.new/0","type":"function"},{"doc":"","ref":"babel_flag.html#new/1","title":"babel_flag.new/1","type":"function"},{"doc":"","ref":"babel_flag.html#new/2","title":"babel_flag.new/2","type":"function"},{"doc":"Returns the original value of the flag.","ref":"babel_flag.html#original_value/1","title":"babel_flag.original_value/1","type":"function"},{"doc":"","ref":"babel_flag.html#set/2","title":"babel_flag.set/2","type":"function"},{"doc":"Sets the context Ctxt .","ref":"babel_flag.html#set_context/2","title":"babel_flag.set_context/2","type":"function"},{"doc":"","ref":"babel_flag.html#to_riak_op/2","title":"babel_flag.to_riak_op/2","type":"function"},{"doc":"Returns the symbolic name of this container.","ref":"babel_flag.html#type/0","title":"babel_flag.type/0","type":"function"},{"doc":"Returns the current value of the flag.","ref":"babel_flag.html#value/1","title":"babel_flag.value/1","type":"function"},{"doc":"","ref":"babel_flag.html#t:babel_context/0","title":"babel_flag.babel_context/0","type":"type"},{"doc":"","ref":"babel_flag.html#t:maybe_no_return/1","title":"babel_flag.maybe_no_return/1","type":"type"},{"doc":"","ref":"babel_flag.html#t:t/0","title":"babel_flag.t/0","type":"opaque"},{"doc":"","ref":"babel_flag.html#t:type_spec/0","title":"babel_flag.type_spec/0","type":"type"},{"doc":"A hash-partitioned index is an index whose contents (index entries) have been partitioned amongst a fixed number of parts (called partitions) using a hashing algorithm to determine in which partition and entry should be located. By partitioning an index into multiple physical parts, you are accessing much smaller objects which makes it faster and more reliable. With hash partitioning, an index entry is placed into a partition based on the result of passing the partitioning key into a hashing algorithm. This object is immutable. Properties: case_sensitive - controls wether the index terms are case sensitive or not. If true all index terms are constructed by performing a string:lowercase/1 on the values. sort_ordering - (NOT BEING USED YET) number_of_partitions - the number of partitions the index has. Each partition is an instance of babel_index_partition and store in Riak KV as a CRDT (the location is defined by the babel_index module properties). partition_algorithm - the hashing algorithm used for calculating the parition for a given partition_by definition. At th moment this property only accepts jch i.e. jump consistent hashing. partition_by - the list of keys or key paths on the target object to extract the values used for partitioning. index_by - the list of keys or key paths on the target object to extract the values used for partitioning.","ref":"babel_hash_partitioned_index.html","title":"babel_hash_partitioned_index","type":"module"},{"doc":"","ref":"babel_hash_partitioned_index.html#aggregate_by/1","title":"babel_hash_partitioned_index.aggregate_by/1","type":"function"},{"doc":"Returns true if the index is case sensitivity.","ref":"babel_hash_partitioned_index.html#case_sensitive/1","title":"babel_hash_partitioned_index.case_sensitive/1","type":"function"},{"doc":"","ref":"babel_hash_partitioned_index.html#covered_fields/1","title":"babel_hash_partitioned_index.covered_fields/1","type":"function"},{"doc":"","ref":"babel_hash_partitioned_index.html#distinguished_key_paths/1","title":"babel_hash_partitioned_index.distinguished_key_paths/1","type":"function"},{"doc":"","ref":"babel_hash_partitioned_index.html#from_riak_dict/1","title":"babel_hash_partitioned_index.from_riak_dict/1","type":"function"},{"doc":"","ref":"babel_hash_partitioned_index.html#index_by/1","title":"babel_hash_partitioned_index.index_by/1","type":"function"},{"doc":"","ref":"babel_hash_partitioned_index.html#init/2","title":"babel_hash_partitioned_index.init/2","type":"function"},{"doc":"","ref":"babel_hash_partitioned_index.html#init_partition/2","title":"babel_hash_partitioned_index.init_partition/2","type":"function"},{"doc":"","ref":"babel_hash_partitioned_index.html#init_partitions/1","title":"babel_hash_partitioned_index.init_partitions/1","type":"function"},{"doc":"","ref":"babel_hash_partitioned_index.html#iterator/3","title":"babel_hash_partitioned_index.iterator/3","type":"function"},{"doc":"","ref":"babel_hash_partitioned_index.html#iterator_done/1","title":"babel_hash_partitioned_index.iterator_done/1","type":"function"},{"doc":"","ref":"babel_hash_partitioned_index.html#iterator_key/1","title":"babel_hash_partitioned_index.iterator_key/1","type":"function"},{"doc":"","ref":"babel_hash_partitioned_index.html#iterator_move/3","title":"babel_hash_partitioned_index.iterator_move/3","type":"function"},{"doc":"","ref":"babel_hash_partitioned_index.html#iterator_values/1","title":"babel_hash_partitioned_index.iterator_values/1","type":"function"},{"doc":"","ref":"babel_hash_partitioned_index.html#match/3","title":"babel_hash_partitioned_index.match/3","type":"function"},{"doc":"","ref":"babel_hash_partitioned_index.html#number_of_partitions/1","title":"babel_hash_partitioned_index.number_of_partitions/1","type":"function"},{"doc":"Returns the partition algorithm name configured for this index.","ref":"babel_hash_partitioned_index.html#partition_algorithm/1","title":"babel_hash_partitioned_index.partition_algorithm/1","type":"function"},{"doc":"","ref":"babel_hash_partitioned_index.html#partition_by/1","title":"babel_hash_partitioned_index.partition_by/1","type":"function"},{"doc":"","ref":"babel_hash_partitioned_index.html#partition_identifier/2","title":"babel_hash_partitioned_index.partition_identifier/2","type":"function"},{"doc":"","ref":"babel_hash_partitioned_index.html#partition_identifier_prefix/1","title":"babel_hash_partitioned_index.partition_identifier_prefix/1","type":"function"},{"doc":"","ref":"babel_hash_partitioned_index.html#partition_identifiers/2","title":"babel_hash_partitioned_index.partition_identifiers/2","type":"function"},{"doc":"Returns the sort ordering configured for this index. The result can be the atoms asc or desc .","ref":"babel_hash_partitioned_index.html#sort_ordering/1","title":"babel_hash_partitioned_index.sort_ordering/1","type":"function"},{"doc":"","ref":"babel_hash_partitioned_index.html#to_riak_object/1","title":"babel_hash_partitioned_index.to_riak_object/1","type":"function"},{"doc":"","ref":"babel_hash_partitioned_index.html#update_partition/3","title":"babel_hash_partitioned_index.update_partition/3","type":"function"},{"doc":"","ref":"babel_hash_partitioned_index.html#t:fields/0","title":"babel_hash_partitioned_index.fields/0","type":"type"},{"doc":"","ref":"babel_hash_partitioned_index.html#t:iterator/0","title":"babel_hash_partitioned_index.iterator/0","type":"type"},{"doc":"","ref":"babel_hash_partitioned_index.html#t:t/0","title":"babel_hash_partitioned_index.t/0","type":"type"},{"doc":"An object that specifies the type and configuration of an application maintained index in Riak KV and the location ({bucket_type(), bucket()}, key()}) of its partitions babel_index_partition in Riak KV. Every Index has one or more partition objects which are modelled as Riak KV maps. An Index is persisted as a read-only CRDT Map as part of an Index Collection babel_index_collection . An Index Collection aggregates all indices for a domain entity or resource e.g. accounts.","ref":"babel_index.html","title":"babel_index","type":"behaviour"},{"doc":"Returns the Riak KV bucket were this index partitions are stored.","ref":"babel_index.html#bucket/1","title":"babel_index.bucket/1","type":"function"},{"doc":"Returns the Riak KV bucket type associated with this index.","ref":"babel_index.html#bucket_type/1","title":"babel_index.bucket_type/1","type":"function"},{"doc":"Returns the configuration associated with this index. The configuration depends on the index type babel:type/1 .","ref":"babel_index.html#config/1","title":"babel_index.config/1","type":"function"},{"doc":"","ref":"babel_index.html#create_partitions/1","title":"babel_index.create_partitions/1","type":"function"},{"doc":"Returns the list of the key paths that need to be present in the key value object passed as an action to update/3 .","ref":"babel_index.html#distinguished_key_paths/1","title":"babel_index.distinguished_key_paths/1","type":"function"},{"doc":"","ref":"babel_index.html#c:distinguished_key_paths/1","title":"babel_index.distinguished_key_paths/1","type":"callback"},{"doc":"","ref":"babel_index.html#foreach/2","title":"babel_index.foreach/2","type":"function"},{"doc":"","ref":"babel_index.html#c:from_riak_dict/1","title":"babel_index.from_riak_dict/1","type":"callback"},{"doc":"","ref":"babel_index.html#from_riak_object/1","title":"babel_index.from_riak_object/1","type":"function"},{"doc":"","ref":"babel_index.html#c:init/2","title":"babel_index.init/2","type":"callback"},{"doc":"","ref":"babel_index.html#c:init_partition/2","title":"babel_index.init_partition/2","type":"callback"},{"doc":"","ref":"babel_index.html#c:iterator/3","title":"babel_index.iterator/3","type":"callback"},{"doc":"","ref":"babel_index.html#c:iterator_done/1","title":"babel_index.iterator_done/1","type":"callback"},{"doc":"","ref":"babel_index.html#c:iterator_key/1","title":"babel_index.iterator_key/1","type":"callback"},{"doc":"","ref":"babel_index.html#c:iterator_move/3","title":"babel_index.iterator_move/3","type":"callback"},{"doc":"","ref":"babel_index.html#c:iterator_values/1","title":"babel_index.iterator_values/1","type":"callback"},{"doc":"Returns a list of matching index entries","ref":"babel_index.html#match/3","title":"babel_index.match/3","type":"function"},{"doc":"","ref":"babel_index.html#c:match/3","title":"babel_index.match/3","type":"callback"},{"doc":"Returns name of this index","ref":"babel_index.html#name/1","title":"babel_index.name/1","type":"function"},{"doc":"Returns a new index based on the specification map. It fails in case the specification in invalid. A specification is map with the following fields (required fields are in bold): **name** :: binary() – a unique name for this index within a collection. **bucket_type** :: binary() | atom() – the bucket type used to store the babel_index_partition:t() objects. This bucket type should have a datatype of map`. **bucket** :: binary() | atom() – the bucket name used to store the babel_index_partition:t() objects of this index. Typically the name of an entity in plural form e.g. accounts'. **type** :: atom() – the index type (Erlang module) used by this index. config :: map() – the configuration data for the index type used by this index.","ref":"babel_index.html#new/1","title":"babel_index.new/1","type":"function"},{"doc":"","ref":"babel_index.html#c:number_of_partitions/1","title":"babel_index.number_of_partitions/1","type":"callback"},{"doc":"Returns the identifier for the index partition assigned for key value object KeyValue when passed as an action to update/3 .","ref":"babel_index.html#partition_identifier/2","title":"babel_index.partition_identifier/2","type":"function"},{"doc":"","ref":"babel_index.html#c:partition_identifier/2","title":"babel_index.partition_identifier/2","type":"callback"},{"doc":"Returns the list of Riak KV keys under which the partitions are stored, in ascending order. This is equivalent to the call partition_identifiers(Index, asc) .","ref":"babel_index.html#partition_identifiers/1","title":"babel_index.partition_identifiers/1","type":"function"},{"doc":"Returns the list of Riak KV keys under which the partitions are stored in a defined order i.e. asc or desc .","ref":"babel_index.html#partition_identifiers/2","title":"babel_index.partition_identifiers/2","type":"function"},{"doc":"","ref":"babel_index.html#c:partition_identifiers/2","title":"babel_index.partition_identifiers/2","type":"callback"},{"doc":"Returns the representation of this object as a Reliable Delete work item.","ref":"babel_index.html#to_delete_task/2","title":"babel_index.to_delete_task/2","type":"function"},{"doc":"","ref":"babel_index.html#to_riak_object/1","title":"babel_index.to_riak_object/1","type":"function"},{"doc":"","ref":"babel_index.html#c:to_riak_object/1","title":"babel_index.to_riak_object/1","type":"callback"},{"doc":"Returns the representation of this object as a Reliable Update work item.","ref":"babel_index.html#to_update_task/2","title":"babel_index.to_update_task/2","type":"function"},{"doc":"Returns the type of this index. A type is a module name implementing the babel_index behaviour i.e. a type of index.","ref":"babel_index.html#type/1","title":"babel_index.type/1","type":"function"},{"doc":"Returns the Riak KV typed_bucket() associated with this index.","ref":"babel_index.html#typed_bucket/1","title":"babel_index.typed_bucket/1","type":"function"},{"doc":"Throws {badaction, update_action()} in case of the action wants to delete a modified map.","ref":"babel_index.html#update/3","title":"babel_index.update/3","type":"function"},{"doc":"","ref":"babel_index.html#c:update_partition/3","title":"babel_index.update_partition/3","type":"callback"},{"doc":"","ref":"babel_index.html#t:fold_fun/0","title":"babel_index.fold_fun/0","type":"type"},{"doc":"","ref":"babel_index.html#t:fold_opts/0","title":"babel_index.fold_opts/0","type":"type"},{"doc":"","ref":"babel_index.html#t:foreach_fun/0","title":"babel_index.foreach_fun/0","type":"type"},{"doc":"","ref":"babel_index.html#t:index_key/0","title":"babel_index.index_key/0","type":"type"},{"doc":"","ref":"babel_index.html#t:index_values/0","title":"babel_index.index_values/0","type":"type"},{"doc":"","ref":"babel_index.html#t:key_value/0","title":"babel_index.key_value/0","type":"type"},{"doc":"","ref":"babel_index.html#t:local_key/0","title":"babel_index.local_key/0","type":"type"},{"doc":"","ref":"babel_index.html#t:maybe_no_return/1","title":"babel_index.maybe_no_return/1","type":"type"},{"doc":"","ref":"babel_index.html#t:partition_id/0","title":"babel_index.partition_id/0","type":"type"},{"doc":"","ref":"babel_index.html#t:partition_key/0","title":"babel_index.partition_key/0","type":"type"},{"doc":"","ref":"babel_index.html#t:query_opts/0","title":"babel_index.query_opts/0","type":"type"},{"doc":"","ref":"babel_index.html#t:riak_object/0","title":"babel_index.riak_object/0","type":"type"},{"doc":"","ref":"babel_index.html#t:t/0","title":"babel_index.t/0","type":"type"},{"doc":"","ref":"babel_index.html#t:update_action/0","title":"babel_index.update_action/0","type":"type"},{"doc":"","ref":"babel_index.html#t:update_opts/0","title":"babel_index.update_opts/0","type":"type"},{"doc":"A babel_index_collection is a Riak Map representing a mapping from binary keys to babel_index objects, where keys are the value of the babel_index:name/1 property. An Index Collection has a name that typically represents the name of a resource (or entity) name in your domain model e.g. accounts, users. A babel collection object is stored in Riak KV under a bucket_type that should be defined through configuration using the index_collection_bucket_type configuration option; and a bucket name which results from concatenating a prefix provided as argument in this module functions and the suffix &quot;/index_collection&quot;. ## Configuring the bucket type The bucket type needs to be configured and activated in Riak KV before using this module. The datatype property of the bucket type should be configured to map . The following example shows how to configure and activate the bucket type with the recommeded default replication properties, for the example we asume the application property index_collection_bucket_type maps to &quot;index_collection&quot; bucket type name. shell riak - admin bucket - type create index_collection &#39;{&quot;props&quot;: {&quot;datatype&quot;:&quot;map&quot;, &quot;n_val&quot;:3, &quot;pw&quot;:&quot;quorum&quot;, &quot;pr&quot;:&quot;quorum&quot;, &quot;notfound_ok&quot;:false, &quot;basic_quorum&quot;:true}}&#39; riak - admin bucket - type activate index_collection ## Default replication properties All functions in this module resulting in reading or writing to Riak KV allow an optional map with Riak KV's replication properties, but we recommend to use of the functions which provide the default replication properties.","ref":"babel_index_collection.html","title":"babel_index_collection","type":"module"},{"doc":"Returns a copy of collection Collection where the index Index has been added. If the an index with the same name existed in the collection, it will be replaced by Index . !&gt; **Important**. This is a private API. If you want to add an index to the collection and create the index in Riak KV use babel:create_index/3 instead.","ref":"babel_index_collection.html#add_index/2","title":"babel_index_collection.add_index/2","type":"function"},{"doc":"","ref":"babel_index_collection.html#bucket/1","title":"babel_index_collection.bucket/1","type":"function"},{"doc":"","ref":"babel_index_collection.html#data/1","title":"babel_index_collection.data/1","type":"function"},{"doc":"","ref":"babel_index_collection.html#delete/3","title":"babel_index_collection.delete/3","type":"function"},{"doc":"","ref":"babel_index_collection.html#delete_index/2","title":"babel_index_collection.delete_index/2","type":"function"},{"doc":"","ref":"babel_index_collection.html#fetch/3","title":"babel_index_collection.fetch/3","type":"function"},{"doc":"","ref":"babel_index_collection.html#fold/3","title":"babel_index_collection.fold/3","type":"function"},{"doc":"","ref":"babel_index_collection.html#from_riak_object/1","title":"babel_index_collection.from_riak_object/1","type":"function"},{"doc":"","ref":"babel_index_collection.html#id/1","title":"babel_index_collection.id/1","type":"function"},{"doc":"Returns the babel index associated with name IndexName in collection Collection . This function assumes that the name is present in the collection. An exception is generated if it is not.","ref":"babel_index_collection.html#index/2","title":"babel_index_collection.index/2","type":"function"},{"doc":"","ref":"babel_index_collection.html#index_names/1","title":"babel_index_collection.index_names/1","type":"function"},{"doc":"Returns all the indices in the collection.","ref":"babel_index_collection.html#indices/1","title":"babel_index_collection.indices/1","type":"function"},{"doc":"","ref":"babel_index_collection.html#is_index/2","title":"babel_index_collection.is_index/2","type":"function"},{"doc":"","ref":"babel_index_collection.html#lookup/3","title":"babel_index_collection.lookup/3","type":"function"},{"doc":"Creates a new index collection object. The value for bucket is computed by concatenating BucketPrefix with the suffix /index_collection .","ref":"babel_index_collection.html#new/2","title":"babel_index_collection.new/2","type":"function"},{"doc":"Returns the number of elements in the collection Collection .","ref":"babel_index_collection.html#size/1","title":"babel_index_collection.size/1","type":"function"},{"doc":"Stores an index collection in Riak KV. The collection will be stored under the bucket type configured for the application option index_collection_bucket_type , bucket name will be the value returned by bucket/1 , and the key will be the value returned by id/1 .","ref":"babel_index_collection.html#store/2","title":"babel_index_collection.store/2","type":"function"},{"doc":"","ref":"babel_index_collection.html#to_delete_task/1","title":"babel_index_collection.to_delete_task/1","type":"function"},{"doc":"","ref":"babel_index_collection.html#to_riak_object/1","title":"babel_index_collection.to_riak_object/1","type":"function"},{"doc":"","ref":"babel_index_collection.html#to_update_task/1","title":"babel_index_collection.to_update_task/1","type":"function"},{"doc":"","ref":"babel_index_collection.html#t:fold_fun/0","title":"babel_index_collection.fold_fun/0","type":"type"},{"doc":"","ref":"babel_index_collection.html#t:key/0","title":"babel_index_collection.key/0","type":"type"},{"doc":"","ref":"babel_index_collection.html#t:riak_object/0","title":"babel_index_collection.riak_object/0","type":"type"},{"doc":"","ref":"babel_index_collection.html#t:t/0","title":"babel_index_collection.t/0","type":"type"},{"doc":"","ref":"babel_index_partition.html","title":"babel_index_partition","type":"module"},{"doc":"","ref":"babel_index_partition.html#created_ts/1","title":"babel_index_partition.created_ts/1","type":"function"},{"doc":"","ref":"babel_index_partition.html#data/1","title":"babel_index_partition.data/1","type":"function"},{"doc":"","ref":"babel_index_partition.html#delete/4","title":"babel_index_partition.delete/4","type":"function"},{"doc":"","ref":"babel_index_partition.html#fetch/3","title":"babel_index_partition.fetch/3","type":"function"},{"doc":"","ref":"babel_index_partition.html#fetch/4","title":"babel_index_partition.fetch/4","type":"function"},{"doc":"","ref":"babel_index_partition.html#from_riak_object/1","title":"babel_index_partition.from_riak_object/1","type":"function"},{"doc":"","ref":"babel_index_partition.html#id/1","title":"babel_index_partition.id/1","type":"function"},{"doc":"","ref":"babel_index_partition.html#last_updated_ts/1","title":"babel_index_partition.last_updated_ts/1","type":"function"},{"doc":"","ref":"babel_index_partition.html#lookup/3","title":"babel_index_partition.lookup/3","type":"function"},{"doc":"","ref":"babel_index_partition.html#lookup/4","title":"babel_index_partition.lookup/4","type":"function"},{"doc":"","ref":"babel_index_partition.html#new/1","title":"babel_index_partition.new/1","type":"function"},{"doc":"","ref":"babel_index_partition.html#new/2","title":"babel_index_partition.new/2","type":"function"},{"doc":"","ref":"babel_index_partition.html#size/1","title":"babel_index_partition.size/1","type":"function"},{"doc":"","ref":"babel_index_partition.html#store/5","title":"babel_index_partition.store/5","type":"function"},{"doc":"","ref":"babel_index_partition.html#to_riak_object/1","title":"babel_index_partition.to_riak_object/1","type":"function"},{"doc":"","ref":"babel_index_partition.html#type/1","title":"babel_index_partition.type/1","type":"function"},{"doc":"","ref":"babel_index_partition.html#update_data/2","title":"babel_index_partition.update_data/2","type":"function"},{"doc":"","ref":"babel_index_partition.html#t:bucket/0","title":"babel_index_partition.bucket/0","type":"type"},{"doc":"","ref":"babel_index_partition.html#t:bucket_and_type/0","title":"babel_index_partition.bucket_and_type/0","type":"type"},{"doc":"","ref":"babel_index_partition.html#t:bucket_type/0","title":"babel_index_partition.bucket_type/0","type":"type"},{"doc":"","ref":"babel_index_partition.html#t:data/0","title":"babel_index_partition.data/0","type":"type"},{"doc":"","ref":"babel_index_partition.html#t:opts/0","title":"babel_index_partition.opts/0","type":"type"},{"doc":"","ref":"babel_index_partition.html#t:riak_object/0","title":"babel_index_partition.riak_object/0","type":"type"},{"doc":"","ref":"babel_index_partition.html#t:t/0","title":"babel_index_partition.t/0","type":"type"},{"doc":"","ref":"babel_index_partition.html#t:typed_bucket/0","title":"babel_index_partition.typed_bucket/0","type":"type"},{"doc":"A collection of utility functions used by the different index type implementations.","ref":"babel_index_utils.html","title":"babel_index_utils","type":"module"},{"doc":"","ref":"babel_index_utils.html#build_output/2","title":"babel_index_utils.build_output/2","type":"function"},{"doc":"","ref":"babel_index_utils.html#build_output/3","title":"babel_index_utils.build_output/3","type":"function"},{"doc":"Collects keys Keys from key value data Data and joins them using a separator. We do this as Riak does not support list and sets are ordered. The values for Keys in Data must be binary strings.","ref":"babel_index_utils.html#gen_key/3","title":"babel_index_utils.gen_key/3","type":"function"},{"doc":"Collects keys Keys from key value data Data and joins them using a separator. We do this as Riak does not support list and sets are ordered. The diff between this function and gen_key/2 is that this one catches exceptions and returns a value.","ref":"babel_index_utils.html#safe_gen_key/3","title":"babel_index_utils.safe_gen_key/3","type":"function"},{"doc":"A Key Value coding interface for property lists and maps.","ref":"babel_key_value.html","title":"babel_key_value","type":"module"},{"doc":"","ref":"babel_key_value.html#collect/2","title":"babel_key_value.collect/2","type":"function"},{"doc":"","ref":"babel_key_value.html#collect/3","title":"babel_key_value.collect/3","type":"function"},{"doc":"","ref":"babel_key_value.html#fold/3","title":"babel_key_value.fold/3","type":"function"},{"doc":"Returns value Value associated with Key if KVTerm contains Key . Key can be an atom, a binary or a path represented as a list of atoms and/ or binaries. The call fails with a {badarg, KVTerm } exception if KVTerm is not a property list, map or Riak CRDT Map. It also fails with a {badkey, Key } exception if no value is associated with Key . &gt; In the case of Riak CRDT Maps a key MUST be a riakc_map:key() .","ref":"babel_key_value.html#get/2","title":"babel_key_value.get/2","type":"function"},{"doc":"","ref":"babel_key_value.html#get/3","title":"babel_key_value.get/3","type":"function"},{"doc":"Equivalent to set / 3.","ref":"babel_key_value.html#put/3","title":"babel_key_value.put/3","type":"function"},{"doc":"","ref":"babel_key_value.html#set/3","title":"babel_key_value.set/3","type":"function"},{"doc":"","ref":"babel_key_value.html#t:fold_fun/0","title":"babel_key_value.fold_fun/0","type":"type"},{"doc":"","ref":"babel_key_value.html#t:key/0","title":"babel_key_value.key/0","type":"type"},{"doc":"","ref":"babel_key_value.html#t:path/0","title":"babel_key_value.path/0","type":"type"},{"doc":"","ref":"babel_key_value.html#t:t/0","title":"babel_key_value.t/0","type":"type"},{"doc":"Provides an alternative to Riak Map Datatype. # Overview Babel maps (maps) differ from Riak's and Erlang's maps in several ways: * Maps are special key-value structures where the key is a binary name and the value is a Babel datatype, each one an alternative of the Riak's counterparts, with the exception of the Riak Register type which can be represented by any Erlang Term in Babel (and not just a binary) provided there exists a valid type conversion specification (see Type Specifications ). * Maps maintain the same semantics as Riak Maps but with some key differences * As with Riak Map, removals, and modifications are captured for later application by Riak but they are also applied to the local state. That is, maps resolve the issue of not being able to read your object mutations in memory that occurs when using Riak maps. * Removals are processed before updates in Riak. Also, removals performed without a context may result in failure. * Updating an entry followed by removing that same entry will result in no operation being recorded. Likewise, removing an entry followed by updating that entry will cancel the removal operation. * You may store or remove values in a map by using set/3`, `remove/2 , and other functions targetting embedded babel containers e.g. add_element/ 3 , add_elements/3 , del_element/3 to modify an embeded babel_set . This is a complete departure from Riak's cumbersome update/3 function. As in Riak Maps, setting or adding a value to an embedded container that is not present will create a new container before the set/add operation. * Certain function e.g. set/3 allows you to set a value in a key or a path (list of nested keys). # Type Specifications A type specification is an Erlang map where the keys are the Babel map keys and their value is another specification or a type_mapping() . For example the specification \#{&lt;&lt;&quot;friends&quot;&gt;&gt; =&gt; {set, list}} , says the map contains a single key name &quot;friends&quot; containing a Babel Set (compatible with Riak Set) where the individual elements are represented in Erlang as lists i.e. a set of lists. This will result in a map containing the key &lt;&lt;&quot;friends&quot;&gt;&gt; and a babel set contining the elements converted from binaries to lists. The special '\\_' key name provides the capability to convert a Riak Map where the keys are not known in advance. These specs can only have a single entry as follows \#{{ \\_', set}, erl_type()}'.","ref":"babel_map.html","title":"babel_map","type":"module"},{"doc":"Adds element Value to a babel set associated with key or path Key in map Map and inserts the association into map NewMap . If the key Key does not exist in map Map , this function creates a new babel set containining Value . The call might fail with the following exception reasons: * {badset, Set} - if the initial value associated with Key in map Map0 is not a babel set; * {badmap, Map} exception if Map is not a babel map. * {badkey, Key} - exception if no value is associated with Key or Key is not of type binary.","ref":"babel_map.html#add_element/3","title":"babel_map.add_element/3","type":"function"},{"doc":"Adds a list of values Values to a babel set associated with key or path Key in map Map and inserts the association into map NewMap . If the key Key does not exist in map Map , this function creates a new babel set containining Values . The call might fail with the following exception reasons: * {badset, Set} - if the initial value associated with Key in map Map0 is not a babel set; * {badmap, Map} exception if Map is not a babel map. * {badkey, Key} - exception if no value is associated with Key or Key is not of type binary.","ref":"babel_map.html#add_elements/3","title":"babel_map.add_elements/3","type":"function"},{"doc":"Returns the status of a key path KeyPath in map Map , where status can be one of updated , removed , both or none .","ref":"babel_map.html#change_status/2","title":"babel_map.change_status/2","type":"function"},{"doc":"Returns the status of a key path KeyPath in map Map , where status can be one of updated , removed , both or none .","ref":"babel_map.html#change_status/3","title":"babel_map.change_status/3","type":"function"},{"doc":"Returns a tuple where the first element is the list of the key paths that have been updated and the second one those which have been removed in map T . Notice that a key path might be both removed and updated, in which case it will be a mamber of both result elements. The call fails with a {badmap, T} exception if T is not a map.","ref":"babel_map.html#changed_key_paths/1","title":"babel_map.changed_key_paths/1","type":"function"},{"doc":"Calls collect/3 with the default options.","ref":"babel_map.html#collect/2","title":"babel_map.collect/2","type":"function"},{"doc":"Returns a list of values associated with the keys Keys . ?&gt; The value returned by this function are not raw values, but Babel datatype values. If you want to get the raw values use collect_values/3 instead. The return depends on the following options: * default - the value to use as default when a key in Keys is not present in the map Map . The presence of a default value disables the option on_badkey . * on_badkey - what happens when a key is not present in the map and there was no default value provided. Valid values are skip , or error . When using skip the function simply ignores the missing key and returns all found keys. Using error will fail with a badkey exception. * return` - the Erlang return type of the function. Valid values are `list and map . Notice that naturally Erlang maps will deduplicate keys whereas lists would not. Default value: list . **Examples**: Map = babel_map:new( \#{ &lt;&lt;&quot;x&quot;&gt;&gt; =&gt; \#{ &lt;&lt;&quot;a&quot;&gt;&gt; =&gt; 1, &lt;&lt;&quot;b&quot;&gt;&gt; =&gt; 2 } }, \#{ &lt;&lt;&quot;x&quot;&gt;&gt; =&gt; {map, \#{ &lt;&lt;&quot;a&quot;&gt;&gt; =&gt; {counter, integer}, &lt;&lt;&quot;b&quot;&gt;&gt; =&gt; {counter, integer} }} } ). babel_map:collect([&lt;&lt;&quot;x&quot;&gt;&gt;], Map). [{babel_map,\#{&lt;&lt;&quot;a&quot;&gt;&gt; =&gt; {babel_counter,0,1}, &lt;&lt;&quot;b&quot;&gt;&gt; =&gt; {babel_counter,0,2}}, [&lt;&lt;&quot;a&quot;&gt;&gt;,&lt;&lt;&quot;b&quot;&gt;&gt;], [],undefined}] babel_map:collect([&lt;&lt;&quot;y&quot;&gt;&gt;], Map). ** exception error: badkey babel_map:collect([&lt;&lt;&quot;y&quot;&gt;&gt;], Map, \#{on_badkey =&gt; skip}). [] babel_map:collect([&lt;&lt;&quot;y&quot;&gt;&gt;], Map, \#{default =&gt; undefined}). [undefined] babel_map:collect([&lt;&lt;&quot;x&quot;&gt;&gt;], Map, \#{return =&gt; map}). \#{&lt;&lt;&quot;x&quot;&gt;&gt; =&gt; {babel_map,\#{&lt;&lt;&quot;a&quot;&gt;&gt; =&gt; {babel_counter,0,1}, &lt;&lt;&quot;b&quot;&gt;&gt; =&gt; {babel_counter,0,2}}, [&lt;&lt;&quot;a&quot;&gt;&gt;,&lt;&lt;&quot;b&quot;&gt;&gt;], [],undefined}} babel_map:collect( [ [&lt;&lt;&quot;x&quot;&gt;&gt;, &lt;&lt;&quot;a&quot;&gt;&gt;], [&lt;&lt;&quot;x&quot;&gt;&gt;, &lt;&lt;&quot;b&quot;&gt;&gt;] ], Map, \#{return =&gt; list} ). [{babel_counter, 0, 1},{babel_counter, 0, 2}] babel_map:collect( [ [&lt;&lt;&quot;x&quot;&gt;&gt;, &lt;&lt;&quot;a&quot;&gt;&gt;], [&lt;&lt;&quot;x&quot;&gt;&gt;, &lt;&lt;&quot;b&quot;&gt;&gt;] ], Map, \#{return =&gt; map} ). \#{&lt;&lt;&quot;x&quot;&gt;&gt; =&gt; \#{&lt;&lt;&quot;a&quot;&gt;&gt; =&gt; {babel_counter,0,1}, &lt;&lt;&quot;b&quot;&gt;&gt; =&gt; {babel_counter,0,2}}} !&gt; The function is not clever in terms of optimisations, so judgment is required when used. For example if Keys = [ [A, B, X], [A, B, Y], [A, B, Z] ] , it will iterate 3 times traversing the whole path from A to X, Y and Z i.e. reading A then B three times. In the future we might want to change this so that [A, B] is read once.","ref":"babel_map.html#collect/3","title":"babel_map.collect/3","type":"function"},{"doc":"Returns a list of values associated with the keys Keys . Fails with a {badkey, K}` exeception if any key `K in Keys is not present in the map.","ref":"babel_map.html#collect_values/2","title":"babel_map.collect_values/2","type":"function"},{"doc":"Returns a list of values associated with the keys Keys . ?&gt; The value returned by this function are the raw values e.g. equivalent to calling get_value/2 on a Babel datatype. If you want to get the container datatype values use collect/3 instead. The return depends on the following options: * default - the value to use as default when a key in Keys is not present in the map Map . The presence of a default value disables the option on_badkey . * on_badkey - what happens when a key is not present in the map and there was no default value provided. Valid values are skip , or error . When using skip the function simply ignores the missing key and returns all found keys. Using error will fail with a badkey exception. * return` - the Erlang return type of the function. Valid values are `list and map . Notice that naturally Erlang maps will deduplicate keys whereas lists would not. Default value: list . **Examples**: Map = babel_map:new( \#{ &lt;&lt;&quot;x&quot;&gt;&gt; =&gt; \#{ &lt;&lt;&quot;a&quot;&gt;&gt; =&gt; 1, &lt;&lt;&quot;b&quot;&gt;&gt; =&gt; 2 } }, \#{ &lt;&lt;&quot;x&quot;&gt;&gt; =&gt; {map, \#{ &lt;&lt;&quot;a&quot;&gt;&gt; =&gt; {counter, integer}, &lt;&lt;&quot;b&quot;&gt;&gt; =&gt; {counter, integer} }} } ). babel_map:collect_values([&lt;&lt;&quot;x&quot;&gt;&gt;], Map). [\#{&lt;&lt;&quot;a&quot;&gt;&gt; =&gt; 1, &lt;&lt;&quot;b&quot;&gt;&gt; =&gt; 2}] babel_map:collect_values([&lt;&lt;&quot;y&quot;&gt;&gt;], Map). ** exception error: badkey babel_map:collect_values([&lt;&lt;&quot;y&quot;&gt;&gt;], Map, \#{on_badkey =&gt; skip}). [] babel_map:collect_values([&lt;&lt;&quot;y&quot;&gt;&gt;], Map, \#{default =&gt; undefined}). [undefined] babel_map:collect_values([&lt;&lt;&quot;x&quot;&gt;&gt;], Map, \#{return =&gt; map}). \#{&lt;&lt;&quot;x&quot;&gt;&gt; =&gt; \#{&lt;&lt;&quot;a&quot;&gt;&gt; =&gt; 1, &lt;&lt;&quot;b&quot;&gt;&gt; =&gt; 2}}. babel_map:collect_values( [ [&lt;&lt;&quot;x&quot;&gt;&gt;, &lt;&lt;&quot;a&quot;&gt;&gt;], [&lt;&lt;&quot;x&quot;&gt;&gt;, &lt;&lt;&quot;b&quot;&gt;&gt;] ], Map, \#{return =&gt; list} ). [1,2] babel_map:collect_values( [ [&lt;&lt;&quot;x&quot;&gt;&gt;, &lt;&lt;&quot;a&quot;&gt;&gt;], [&lt;&lt;&quot;x&quot;&gt;&gt;, &lt;&lt;&quot;b&quot;&gt;&gt;] ], Map, \#{return =&gt; map} ). \#{&lt;&lt;&quot;x&quot;&gt;&gt; =&gt; \#{&lt;&lt;&quot;a&quot;&gt;&gt; =&gt; 1, &lt;&lt;&quot;b&quot;&gt;&gt; =&gt; 2}} !&gt; The function is not clever in terms of optimisations, so judgment is required when used. For example if Keys = [ [A, B, X], [A, B, Y], [A, B, Z] ] , it will iterate 3 times traversing the whole path from A to X, Y and Z i.e. reading A then B three times. In the future we might want to change this so that [A, B] is read once.","ref":"babel_map.html#collect_values/3","title":"babel_map.collect_values/3","type":"function"},{"doc":"Returns the Riak KV context associated with map T . The call fails with a {badmap, T} exception if T is not a map.","ref":"babel_map.html#context/1","title":"babel_map.context/1","type":"function"},{"doc":"","ref":"babel_map.html#decrement/2","title":"babel_map.decrement/2","type":"function"},{"doc":"","ref":"babel_map.html#decrement/3","title":"babel_map.decrement/3","type":"function"},{"doc":"Returns a new map NewMap were the value Value has been removed from a babel set associated with key or path Key in map Map . If the key Key does not exist in map Map , this function creates a new babel set recording the removal of Value . The call might fail with the following exception reasons: * {badset, Set} - if the initial value associated with Key in map Map0 is not a babel set; * {badmap, Map} exception if Map is not a babel map. * {badkey, Key} - exception if no value is associated with Key or Key is not of type binary.","ref":"babel_map.html#del_element/3","title":"babel_map.del_element/3","type":"function"},{"doc":"","ref":"babel_map.html#disable/2","title":"babel_map.disable/2","type":"function"},{"doc":"","ref":"babel_map.html#enable/2","title":"babel_map.enable/2","type":"function"},{"doc":"Returns the tuple {ok, Value :: any()} if the key 'Key' is associated with value Value in map T . Otherwise returns the atom error . The call fails with a {badmap, T} exception if T is not a map and {badkey, Key} exception if Key is not a binary term.","ref":"babel_map.html#find/2","title":"babel_map.find/2","type":"function"},{"doc":"Returns a new map by applying the type specification Spec to the Riak Map RMap .","ref":"babel_map.html#from_riak_map/2","title":"babel_map.from_riak_map/2","type":"function"},{"doc":"Returns a new map by applying the type specification Spec to the Riak Map RMap . Options is a map containing th following options: * missing_spec -- the strategy to deal with a field found in the Riak Map that does not have a mapping in the type specificiation Spec . It accepts the values error` or `ignore`. In the case of `error` a `{missing_spec, Key} exception will be raised; in the case or ignore it will simply be ignored. The default is error .","ref":"babel_map.html#from_riak_map/3","title":"babel_map.from_riak_map/3","type":"function"},{"doc":"Returns value Value associated with Key if T contains Key . Key can be a binary or a path represented as a list of binaries. The call fails with a {badarg, T } exception if T is not a Babel Map. It also fails with a {badkey, Key } exception if no value is associated with Key or if Key is not a binary term.","ref":"babel_map.html#get/2","title":"babel_map.get/2","type":"function"},{"doc":"Returns value Value associated with Key if T contains Key , or the default value Default in case T does not contain Key . Key can be a binary or a path represented as a list of binaries. The call fails with a {badarg, T}` exception if `T is not a Babel Map. It also fails with a {badkey, Key}` exception if no value is associated with `Key or if Key is not a binary term.","ref":"babel_map.html#get/3","title":"babel_map.get/3","type":"function"},{"doc":"","ref":"babel_map.html#get_registered_type_spec/1","title":"babel_map.get_registered_type_spec/1","type":"function"},{"doc":"An util function equivalent to calling DatatypeMod:value(get(Key, T)) .","ref":"babel_map.html#get_value/2","title":"babel_map.get_value/2","type":"function"},{"doc":"An util function equivalent to calling DatatypeMod:value(get(Key, T, Default)) .","ref":"babel_map.html#get_value/3","title":"babel_map.get_value/3","type":"function"},{"doc":"Returns true if at least one property of the map has been updated (or inserted) or removed and false otherwise.","ref":"babel_map.html#has_changes/1","title":"babel_map.has_changes/1","type":"function"},{"doc":"","ref":"babel_map.html#increment/2","title":"babel_map.increment/2","type":"function"},{"doc":"","ref":"babel_map.html#increment/3","title":"babel_map.increment/3","type":"function"},{"doc":"Returns true if term Term is a babel map. The call fails with a {badmap, Term} exception if Term is not a map.","ref":"babel_map.html#is_type/1","title":"babel_map.is_type/1","type":"function"},{"doc":"Returns a complete list of keys, in any order, which resides within map T . The call fails with a {badmap, T} exception if T is not a map.","ref":"babel_map.html#keys/1","title":"babel_map.keys/1","type":"function"},{"doc":"Creates a new empty map.","ref":"babel_map.html#new/0","title":"babel_map.new/0","type":"function"},{"doc":"Creates a new map from the erlang map Data , previously filtering out all keys assigned to the undefined . This function converts the erlang types map() , list() and boolean() to their corresponding Babel Datatypes babel_map:t() , babel_map:set() and babel_map:flag() . Any other value will be assumed to be a register. Also, there is not type validation or coersion when creating a babel_set:t() out of a list. !&gt; **Important**. Notice that using this function might result in incompatible types when later using a type specification e.g. to_riak_op/2 . We strongly suggest not using this function and using new/2 instead.","ref":"babel_map.html#new/1","title":"babel_map.new/1","type":"function"},{"doc":"Equivalent to new(Data, Spec, undefined) .","ref":"babel_map.html#new/2","title":"babel_map.new/2","type":"function"},{"doc":"Creates a new Babel Map from the erlang map Data , previously filtering out all keys assigned to the undefined .","ref":"babel_map.html#new/3","title":"babel_map.new/3","type":"function"},{"doc":"Updates a map T with the provide key-value action list ActionList . If the value associated with a key Key in Values is equal to undefined` this equivalent to calling `remove(Key, Map) with the difference that an exception will not be raised in case the map had no context assigned. This function fails with missing_spec if it does not have a type specification reference. See update/3 to pass a type specification.","ref":"babel_map.html#patch/2","title":"babel_map.patch/2","type":"function"},{"doc":"Updates a map T with the provide key-value action list ActionList . If the value associated with a key Key in Values is equal to undefined` this equivalent to calling `remove(Key, Map) with the difference that an exception will not be raised in case the map had no context assigned. Example:","ref":"babel_map.html#patch/3","title":"babel_map.patch/3","type":"function"},{"doc":"Same as set/3 .","ref":"babel_map.html#put/3","title":"babel_map.put/3","type":"function"},{"doc":"Equivalent to register_type_spec(undefined, Spec) . Registers a type specification Spec and returns a type_spec_ref() that can be use with any other map instance of the same kind. A registered type spec is validated during registration and the registration fails if it does not pass the validation. All functions that take a type specification as argument also accept a type specification reference, which is more efficient as there is no need to have the type specification in the local process memery and there is no need for further validation. This call fails with exception {invalid_spec, Errors :: map()} if the type specification Spec is invalid. The storage for specifications is implemented using persistent_term . So refer to that module's documentation to understand best practices. In particular, it is ideal to register the type specifications as soon as your aplication starts in order to minimize the number of processes on the node before performing a registration. It would also be wise to avoid registering type specifications when the system is at peak load.","ref":"babel_map.html#register_type_spec/1","title":"babel_map.register_type_spec/1","type":"function"},{"doc":"Registers a type specification Spec under a reference using unique identifier Id . Returns a type_spec_ref() . If Id equals undefined , then id is computed by computing a hash of value of Spec . The returned reference can be use with any other map instance of the same kind. A registered type spec is validated during registration and the registration fails if it does not pass the validation. All functions that take a type specification as argument also accept a type specification reference, which is more efficient as there is no need to have the type specification in the local process memery and there is no need for further validation. This call fails with exception {invalid_spec, Errors :: map()} if the type specification Spec is invalid. The storage for specifications is implemented using persistent_term . So refer to that module's documentation to understand best practices. In particular, it is ideal to register the type specifications as soon as your aplication starts in order to minimize the number of processes on the node before performing a registration. It would also be wise to avoid registering type specifications when the system is at peak load.","ref":"babel_map.html#register_type_spec/2","title":"babel_map.register_type_spec/2","type":"function"},{"doc":"Removes a key and its value from the map. Removing a key that does not exist simply records a remove operation. In case the map has no context i.e. it is newly created, removes will only %% work for keys that have been updated since creation. In all other cases the call will fail with a context_required exception.","ref":"babel_map.html#remove/2","title":"babel_map.remove/2","type":"function"},{"doc":"Associates Key with value Value and inserts the association into map NewMap . If key Key already exists in map Map , the old associated value is replaced by value Value . The function returns a new map NewMap containing the new association and the old associations in Map . Passing a Value of undefined` is equivalent to calling `remove(Key, Map) with the difference that an exception will not be raised in case the map had no context assigned. The call fails with a {badmap, Term} exception if Map or any value of a partial key path is not a babel map.","ref":"babel_map.html#set/3","title":"babel_map.set/3","type":"function"},{"doc":"Sets the context Ctxt .","ref":"babel_map.html#set_context/2","title":"babel_map.set_context/2","type":"function"},{"doc":"Sets a list of values Values to a babel set associated with key or path Key in map Map and inserts the association into map NewMap . See babel_set:set_elements/2 . If the key Key does not exist in map Map , this function creates a new babel set containining Values . The call might fail with the following exception reasons: * {badset, Set} - if the initial value associated with Key in map Map0 is not a babel set; * {badmap, Map} exception if Map is not a babel map. * {badkey, Key} - exception if no value is associated with Key or Key is not of type binary.","ref":"babel_map.html#set_elements/3","title":"babel_map.set_elements/3","type":"function"},{"doc":"Returns the size of the values of the map T . The call fails with a {badmap, T} exception if T is not a map.","ref":"babel_map.html#size/1","title":"babel_map.size/1","type":"function"},{"doc":"Extracts a Riak Operation from the map to be used with a Riak Client update request. The call fails with a {badmap, T} exception if T is not a map and missing_spec if it does not have a type specification reference.","ref":"babel_map.html#to_riak_op/1","title":"babel_map.to_riak_op/1","type":"function"},{"doc":"Extracts a Riak Operation from the map to be used with a Riak Client update request. The call fails with a {badmap, T} exception if T is not a map.","ref":"babel_map.html#to_riak_op/2","title":"babel_map.to_riak_op/2","type":"function"},{"doc":"Returns the symbolic name of this container.","ref":"babel_map.html#type/0","title":"babel_map.type/0","type":"function"},{"doc":"Returns the type specification reference associated with map T or undefined is there is none.","ref":"babel_map.html#type_spec_ref/1","title":"babel_map.type_spec_ref/1","type":"function"},{"doc":"","ref":"babel_map.html#unregister_type_spec/1","title":"babel_map.unregister_type_spec/1","type":"function"},{"doc":"Updates a map T with the provide key-value pairs Values . If the value associated with a key Key in Values is equal to undefined` this equivalent to calling `remove(Key, Map) with the difference that an exception will not be raised in case the map had no context assigned. This function fails with missing_spec if it does not have a type specification reference. See update/3 to pass a type specification.","ref":"babel_map.html#update/2","title":"babel_map.update/2","type":"function"},{"doc":"Updates a map T with the provide key-value pairs Values . If the value associated with a key Key in Values is equal to undefined` this equivalent to calling `remove(Key, Map) with the difference that an exception will not be raised in case the map had no context assigned.","ref":"babel_map.html#update/3","title":"babel_map.update/3","type":"function"},{"doc":"","ref":"babel_map.html#validate_type_spec/1","title":"babel_map.validate_type_spec/1","type":"function"},{"doc":"Returns an external representation of the map Map as an Erlang map(). This is build recursively by calling the value/1 function on any embedded datatype. The call fails with a {badmap, T} exception if T is not a map.","ref":"babel_map.html#value/1","title":"babel_map.value/1","type":"function"},{"doc":"","ref":"babel_map.html#t:action/0","title":"babel_map.action/0","type":"type"},{"doc":"","ref":"babel_map.html#t:babel_context/0","title":"babel_map.babel_context/0","type":"type"},{"doc":"","ref":"babel_map.html#t:collect_opts/0","title":"babel_map.collect_opts/0","type":"type"},{"doc":"","ref":"babel_map.html#t:datatype/0","title":"babel_map.datatype/0","type":"type"},{"doc":"","ref":"babel_map.html#t:erl_type/0","title":"babel_map.erl_type/0","type":"type"},{"doc":"","ref":"babel_map.html#t:key/0","title":"babel_map.key/0","type":"type"},{"doc":"","ref":"babel_map.html#t:key_path/0","title":"babel_map.key_path/0","type":"type"},{"doc":"","ref":"babel_map.html#t:maybe_no_return/1","title":"babel_map.maybe_no_return/1","type":"type"},{"doc":"","ref":"babel_map.html#t:t/0","title":"babel_map.t/0","type":"opaque"},{"doc":"","ref":"babel_map.html#t:type_mapping/0","title":"babel_map.type_mapping/0","type":"type"},{"doc":"","ref":"babel_map.html#t:type_spec/0","title":"babel_map.type_spec/0","type":"type"},{"doc":"","ref":"babel_map.html#t:type_spec_ref/0","title":"babel_map.type_spec_ref/0","type":"type"},{"doc":"","ref":"babel_map.html#t:value/0","title":"babel_map.value/0","type":"type"},{"doc":"","ref":"babel_set.html","title":"babel_set","type":"module"},{"doc":"Adds an element to the set. You may add an element that already exists in the original set value, but it does not count for the object's size calculation. Adding an element that already exists is non-intuitive, but acts as a safety feature: a client code path that requires an element to be present in the set (or removed) can ensure that intended state by applying an operation.","ref":"babel_set.html#add_element/2","title":"babel_set.add_element/2","type":"function"},{"doc":"","ref":"babel_set.html#add_elements/2","title":"babel_set.add_elements/2","type":"function"},{"doc":"Returns the Riak KV context","ref":"babel_set.html#context/1","title":"babel_set.context/1","type":"function"},{"doc":"Removes an element from the set. You may remove an element that does not appear in the original set value. This is non-intuitive, but acts as a safety feature: a client code path that requires an element to be present in the set (or removed) can ensure that intended state by applying an operation.","ref":"babel_set.html#del_element/2","title":"babel_set.del_element/2","type":"function"},{"doc":"Removes an element from the set. You may remove an element that does not appear in the original set value. This is non-intuitive, but acts as a safety feature: a client code path that requires an element to be present in the set (or removed) can ensure that intended state by applying an operation.","ref":"babel_set.html#del_elements/2","title":"babel_set.del_elements/2","type":"function"},{"doc":"Folds over the members of the set.","ref":"babel_set.html#fold/3","title":"babel_set.fold/3","type":"function"},{"doc":"","ref":"babel_set.html#from_riak_set/2","title":"babel_set.from_riak_set/2","type":"function"},{"doc":"Test whether an element is a member of the set.","ref":"babel_set.html#is_element/2","title":"babel_set.is_element/2","type":"function"},{"doc":"Test whether an element is a member of the original set i,e. the one retrieved from Riak.","ref":"babel_set.html#is_original_element/2","title":"babel_set.is_original_element/2","type":"function"},{"doc":"","ref":"babel_set.html#is_type/1","title":"babel_set.is_type/1","type":"function"},{"doc":"","ref":"babel_set.html#is_valid_type_spec/1","title":"babel_set.is_valid_type_spec/1","type":"function"},{"doc":"","ref":"babel_set.html#new/0","title":"babel_set.new/0","type":"function"},{"doc":"!&gt; **Important**. Notice that using this function might result in incompatible types when later using a type specification e.g. to_riak_op/2 . We strongly suggest not using this function and using new/2 instead.","ref":"babel_set.html#new/1","title":"babel_set.new/1","type":"function"},{"doc":"","ref":"babel_set.html#new/2","title":"babel_set.new/2","type":"function"},{"doc":"Returns the original value of the set as an ordset. This is equivalent to riakc_set:value/1 but where the elements are binaries but of the type defined by the conversion spec() used to create the set.","ref":"babel_set.html#original_value/1","title":"babel_set.original_value/1","type":"function"},{"doc":"Sets the context Ctxt .","ref":"babel_set.html#set_context/2","title":"babel_set.set_context/2","type":"function"},{"doc":"","ref":"babel_set.html#set_elements/2","title":"babel_set.set_elements/2","type":"function"},{"doc":"Returns the cardinality (size) of the set.","ref":"babel_set.html#size/1","title":"babel_set.size/1","type":"function"},{"doc":"Returns a copy of Set1 containing only the elements of Set1 that are not also elements of Set2.","ref":"babel_set.html#subtract/2","title":"babel_set.subtract/2","type":"function"},{"doc":"","ref":"babel_set.html#to_riak_op/2","title":"babel_set.to_riak_op/2","type":"function"},{"doc":"Returns the symbolic name of this container.","ref":"babel_set.html#type/0","title":"babel_set.type/0","type":"function"},{"doc":"","ref":"babel_set.html#type_spec/1","title":"babel_set.type_spec/1","type":"function"},{"doc":"Returns the current value of the set.","ref":"babel_set.html#value/1","title":"babel_set.value/1","type":"function"},{"doc":"","ref":"babel_set.html#t:babel_context/0","title":"babel_set.babel_context/0","type":"type"},{"doc":"","ref":"babel_set.html#t:maybe_no_return/1","title":"babel_set.maybe_no_return/1","type":"type"},{"doc":"","ref":"babel_set.html#t:t/0","title":"babel_set.t/0","type":"opaque"},{"doc":"","ref":"babel_set.html#t:type_spec/0","title":"babel_set.type_spec/0","type":"type"},{"doc":"This object is immutable.","ref":"babel_simple_index.html","title":"babel_simple_index","type":"module"},{"doc":"Returns true if the index is case sensitivity.","ref":"babel_simple_index.html#case_sensitive/1","title":"babel_simple_index.case_sensitive/1","type":"function"},{"doc":"","ref":"babel_simple_index.html#covered_fields/1","title":"babel_simple_index.covered_fields/1","type":"function"},{"doc":"","ref":"babel_simple_index.html#distinguished_key_paths/1","title":"babel_simple_index.distinguished_key_paths/1","type":"function"},{"doc":"","ref":"babel_simple_index.html#from_riak_dict/1","title":"babel_simple_index.from_riak_dict/1","type":"function"},{"doc":"","ref":"babel_simple_index.html#index_by/1","title":"babel_simple_index.index_by/1","type":"function"},{"doc":"","ref":"babel_simple_index.html#init/2","title":"babel_simple_index.init/2","type":"function"},{"doc":"","ref":"babel_simple_index.html#init_partition/2","title":"babel_simple_index.init_partition/2","type":"function"},{"doc":"","ref":"babel_simple_index.html#init_partitions/1","title":"babel_simple_index.init_partitions/1","type":"function"},{"doc":"","ref":"babel_simple_index.html#iterator/3","title":"babel_simple_index.iterator/3","type":"function"},{"doc":"","ref":"babel_simple_index.html#iterator_done/1","title":"babel_simple_index.iterator_done/1","type":"function"},{"doc":"","ref":"babel_simple_index.html#iterator_key/1","title":"babel_simple_index.iterator_key/1","type":"function"},{"doc":"","ref":"babel_simple_index.html#iterator_move/3","title":"babel_simple_index.iterator_move/3","type":"function"},{"doc":"","ref":"babel_simple_index.html#iterator_values/1","title":"babel_simple_index.iterator_values/1","type":"function"},{"doc":"","ref":"babel_simple_index.html#match/3","title":"babel_simple_index.match/3","type":"function"},{"doc":"","ref":"babel_simple_index.html#number_of_partitions/1","title":"babel_simple_index.number_of_partitions/1","type":"function"},{"doc":"","ref":"babel_simple_index.html#partition_identifier/2","title":"babel_simple_index.partition_identifier/2","type":"function"},{"doc":"","ref":"babel_simple_index.html#partition_identifier_prefix/1","title":"babel_simple_index.partition_identifier_prefix/1","type":"function"},{"doc":"","ref":"babel_simple_index.html#partition_identifiers/2","title":"babel_simple_index.partition_identifiers/2","type":"function"},{"doc":"Returns the sort ordering configured for this index. The result can be the atoms asc or desc .","ref":"babel_simple_index.html#sort_ordering/1","title":"babel_simple_index.sort_ordering/1","type":"function"},{"doc":"","ref":"babel_simple_index.html#to_riak_object/1","title":"babel_simple_index.to_riak_object/1","type":"function"},{"doc":"","ref":"babel_simple_index.html#update_partition/3","title":"babel_simple_index.update_partition/3","type":"function"},{"doc":"","ref":"babel_simple_index.html#t:fields/0","title":"babel_simple_index.fields/0","type":"type"},{"doc":"","ref":"babel_simple_index.html#t:iterator/0","title":"babel_simple_index.iterator/0","type":"type"},{"doc":"","ref":"babel_simple_index.html#t:t/0","title":"babel_simple_index.t/0","type":"type"},{"doc":"","ref":"babel_sup.html","title":"babel_sup","type":"module"},{"doc":"","ref":"babel_sup.html#init/1","title":"babel_sup.init/1","type":"function"},{"doc":"","ref":"babel_sup.html#start_link/0","title":"babel_sup.start_link/0","type":"function"},{"doc":"","ref":"babel_utils.html","title":"babel_utils","type":"module"},{"doc":"","ref":"babel_utils.html#from_binary/2","title":"babel_utils.from_binary/2","type":"function"},{"doc":"","ref":"babel_utils.html#to_binary/2","title":"babel_utils.to_binary/2","type":"function"},{"doc":"","ref":"babel_utils.html#t:type/0","title":"babel_utils.type/0","type":"type"},{"doc":"Babel is an Erlang OTP application that allows you to work with Riak KV conflict-free replicated datatypes (CRDTs) and also maintain application-managed secondary indices.","ref":"readme.html","title":"Babel - Riak Datatypes and Secondary Indexing","type":"extras"},{"doc":"THe documentation is available here .","ref":"readme.html#documentation","title":"Babel - Riak Datatypes and Secondary Indexing - Documentation","type":"extras"},{"doc":"Apache License Version 2.0, January 2004 http://www.apache.org/licenses/ TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION 1. Definitions. &quot;License&quot; shall mean the terms and conditions for use, reproduction, and distribution as defined by Sections 1 through 9 of this document. &quot;Licensor&quot; shall mean the copyright owner or entity authorized by the copyright owner that is granting the License. &quot;Legal Entity&quot; shall mean the union of the acting entity and all other entities that control, are controlled by, or are under common control with that entity. For the purposes of this definition, &quot;control&quot; means (i) the power, direct or indirect, to cause the direction or management of such entity, whether by contract or otherwise, or (ii) ownership of fifty percent (50%) or more of the outstanding shares, or (iii) beneficial ownership of such entity. &quot;You&quot; (or &quot;Your&quot;) shall mean an individual or Legal Entity exercising permissions granted by this License. &quot;Source&quot; form shall mean the preferred form for making modifications, including but not limited to software source code, documentation source, and configuration files. &quot;Object&quot; form shall mean any form resulting from mechanical transformation or translation of a Source form, including but not limited to compiled object code, generated documentation, and conversions to other media types. &quot;Work&quot; shall mean the work of authorship, whether in Source or Object form, made available under the License, as indicated by a copyright notice that is included in or attached to the work (an example is provided in the Appendix below). &quot;Derivative Works&quot; shall mean any work, whether in Source or Object form, that is based on (or derived from) the Work and for which the editorial revisions, annotations, elaborations, or other modifications represent, as a whole, an original work of authorship. For the purposes of this License, Derivative Works shall not include works that remain separable from, or merely link (or bind by name) to the interfaces of, the Work and Derivative Works thereof. &quot;Contribution&quot; shall mean any work of authorship, including the original version of the Work and any modifications or additions to that Work or Derivative Works thereof, that is intentionally submitted to Licensor for inclusion in the Work by the copyright owner or by an individual or Legal Entity authorized to submit on behalf of the copyright owner. For the purposes of this definition, &quot;submitted&quot; means any form of electronic, verbal, or written communication sent to the Licensor or its representatives, including but not limited to communication on electronic mailing lists, source code control systems, and issue tracking systems that are managed by, or on behalf of, the Licensor for the purpose of discussing and improving the Work, but excluding communication that is conspicuously marked or otherwise designated in writing by the copyright owner as &quot;Not a Contribution.&quot; &quot;Contributor&quot; shall mean Licensor and any individual or Legal Entity on behalf of whom a Contribution has been received by Licensor and subsequently incorporated within the Work. 2. Grant of Copyright License. Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable copyright license to reproduce, prepare Derivative Works of, publicly display, publicly perform, sublicense, and distribute the Work and such Derivative Works in Source or Object form. 3. Grant of Patent License. Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable (except as stated in this section) patent license to make, have made, use, offer to sell, sell, import, and otherwise transfer the Work, where such license applies only to those patent claims licensable by such Contributor that are necessarily infringed by their Contribution(s) alone or by combination of their Contribution(s) with the Work to which such Contribution(s) was submitted. If You institute patent litigation against any entity (including a cross-claim or counterclaim in a lawsuit) alleging that the Work or a Contribution incorporated within the Work constitutes direct or contributory patent infringement, then any patent licenses granted to You under this License for that Work shall terminate as of the date such litigation is filed. 4. Redistribution. You may reproduce and distribute copies of the Work or Derivative Works thereof in any medium, with or without modifications, and in Source or Object form, provided that You meet the following conditions: (a) You must give any other recipients of the Work or Derivative Works a copy of this License; and (b) You must cause any modified files to carry prominent notices stating that You changed the files; and (c) You must retain, in the Source form of any Derivative Works that You distribute, all copyright, patent, trademark, and attribution notices from the Source form of the Work, excluding those notices that do not pertain to any part of the Derivative Works; and (d) If the Work includes a &quot;NOTICE&quot; text file as part of its distribution, then any Derivative Works that You distribute must include a readable copy of the attribution notices contained within such NOTICE file, excluding those notices that do not pertain to any part of the Derivative Works, in at least one of the following places: within a NOTICE text file distributed as part of the Derivative Works; within the Source form or documentation, if provided along with the Derivative Works; or, within a display generated by the Derivative Works, if and wherever such third-party notices normally appear. The contents of the NOTICE file are for informational purposes only and do not modify the License. You may add Your own attribution notices within Derivative Works that You distribute, alongside or as an addendum to the NOTICE text from the Work, provided that such additional attribution notices cannot be construed as modifying the License. You may add Your own copyright statement to Your modifications and may provide additional or different license terms and conditions for use, reproduction, or distribution of Your modifications, or for any such Derivative Works as a whole, provided Your use, reproduction, and distribution of the Work otherwise complies with the conditions stated in this License. 5. Submission of Contributions. Unless You explicitly state otherwise, any Contribution intentionally submitted for inclusion in the Work by You to the Licensor shall be under the terms and conditions of this License, without any additional terms or conditions. Notwithstanding the above, nothing herein shall supersede or modify the terms of any separate license agreement you may have executed with Licensor regarding such Contributions. 6. Trademarks. This License does not grant permission to use the trade names, trademarks, service marks, or product names of the Licensor, except as required for reasonable and customary use in describing the origin of the Work and reproducing the content of the NOTICE file. 7. Disclaimer of Warranty. Unless required by applicable law or agreed to in writing, Licensor provides the Work (and each Contributor provides its Contributions) on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied, including, without limitation, any warranties or conditions of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A PARTICULAR PURPOSE. You are solely responsible for determining the appropriateness of using or redistributing the Work and assume any risks associated with Your exercise of permissions under this License. 8. Limitation of Liability. In no event and under no legal theory, whether in tort (including negligence), contract, or otherwise, unless required by applicable law (such as deliberate and grossly negligent acts) or agreed to in writing, shall any Contributor be liable to You for damages, including any direct, indirect, special, incidental, or consequential damages of any character arising as a result of this License or out of the use or inability to use the Work (including but not limited to damages for loss of goodwill, work stoppage, computer failure or malfunction, or any and all other commercial damages or losses), even if such Contributor has been advised of the possibility of such damages. 9. Accepting Warranty or Additional Liability. While redistributing the Work or Derivative Works thereof, You may choose to offer, and charge a fee for, acceptance of support, warranty, indemnity, or other liability obligations and/or rights consistent with this License. However, in accepting such obligations, You may act only on Your own behalf and on Your sole responsibility, not on behalf of any other Contributor, and only if You agree to indemnify, defend, and hold each Contributor harmless for any liability incurred by, or claims asserted against, such Contributor by reason of your accepting any such warranty or additional liability. END OF TERMS AND CONDITIONS APPENDIX: How to apply the Apache License to your work. To apply the Apache License to your work, attach the following boilerplate notice, with the fields enclosed by brackets &quot;[]&quot; replaced with your own identifying information. (Don't include the brackets!) The text should be enclosed in the appropriate comment syntax for the file format. We also recommend that a file or class name and description of purpose be included on the same &quot;printed page&quot; as the copyright notice for easier identification within third-party archives. Copyright (c) 2022 Leapsight Technologies Limited. All rights reserved. Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","ref":"license.html","title":"LICENSE","type":"extras"},{"doc":"","ref":"changelog.html","title":"CHANGELOG","type":"extras"},{"doc":"","ref":"code_of_conduct.html","title":"Contributor Covenant Code of Conduct","type":"extras"},{"doc":"We as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation. We pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community.","ref":"code_of_conduct.html#our-pledge","title":"Contributor Covenant Code of Conduct - Our Pledge","type":"extras"},{"doc":"Examples of behavior that contributes to a positive environment for our community include: Demonstrating empathy and kindness toward other people Being respectful of differing opinions, viewpoints, and experiences Giving and gracefully accepting constructive feedback Accepting responsibility and apologizing to those affected by our mistakes, and learning from the experience Focusing on what is best not just for us as individuals, but for the overall community Examples of unacceptable behavior include: The use of sexualized language or imagery, and sexual attention or advances of any kind Trolling, insulting or derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or email address, without their explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting","ref":"code_of_conduct.html#our-standards","title":"Contributor Covenant Code of Conduct - Our Standards","type":"extras"},{"doc":"Community leaders are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful. Community leaders have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, and will communicate reasons for moderation decisions when appropriate. Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at info@leapsight.com.","ref":"code_of_conduct.html#enforcement-responsibilities","title":"Contributor Covenant Code of Conduct - Enforcement Responsibilities","type":"extras"},{"doc":"This Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public spaces. Examples of representing our community include using an official e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event.","ref":"code_of_conduct.html#scope","title":"Contributor Covenant Code of Conduct - Scope","type":"extras"},{"doc":"Instances of abusive, harassing, or otherwise unacceptable behavior may be reported to the community leaders responsible for enforcement at [INSERT CONTACT METHOD]. All complaints will be reviewed and investigated promptly and fairly. All community leaders are obligated to respect the privacy and security of the reporter of any incident.","ref":"code_of_conduct.html#enforcement","title":"Contributor Covenant Code of Conduct - Enforcement","type":"extras"},{"doc":"Community leaders will follow these Community Impact Guidelines in determining the consequences for any action they deem in violation of this Code of Conduct: 1. Correction Community Impact : Use of inappropriate language or other behavior deemed unprofessional or unwelcome in the community. Consequence : A private, written warning from community leaders, providing clarity around the nature of the violation and an explanation of why the behavior was inappropriate. A public apology may be requested. 2. Warning Community Impact : A violation through a single incident or series of actions. Consequence : A warning with consequences for continued behavior. No interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, for a specified period of time. This includes avoiding interactions in community spaces as well as external channels like social media. Violating these terms may lead to a temporary or permanent ban. 3. Temporary Ban Community Impact : A serious violation of community standards, including sustained inappropriate behavior. Consequence : A temporary ban from any sort of interaction or public communication with the community for a specified period of time. No public or private interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, is allowed during this period. Violating these terms may lead to a permanent ban. 4. Permanent Ban Community Impact : Demonstrating a pattern of violation of community standards, including sustained inappropriate behavior, harassment of an individual, or aggression toward or disparagement of classes of individuals. Consequence : A permanent ban from any sort of public interaction within the community.","ref":"code_of_conduct.html#enforcement-guidelines","title":"Contributor Covenant Code of Conduct - Enforcement Guidelines","type":"extras"},{"doc":"This Code of Conduct is adapted from the Contributor Covenant , version 2.0, available at https://www.contributor-covenant.org/version/2/0/code_of_conduct.html . Community Impact Guidelines were inspired by Mozilla's code of conduct enforcement ladder . For answers to common questions about this code of conduct, see the FAQ at https://www.contributor-covenant.org/faq . Translations are available at https://www.contributor-covenant.org/translations .","ref":"code_of_conduct.html#attribution","title":"Contributor Covenant Code of Conduct - Attribution","type":"extras"}]